from flask import Flask, render_template, request, redirect, url_for
from bs4 import BeautifulSoup
import re
from vulnerability_checks import check_sql_injection, check_xss, check_csrf, check_open_redirect
import os  # For environment variable access
import uuid
from urllib.parse import urlparse

def is_valid_url(url):
    """
    Validates the structure of a given URL.

    Args:
        url (str): The URL to validate.

    Returns:
        bool: True if the URL is valid, False otherwise.
    """
    try:
        result = urlparse(url)
        return all([result.scheme, result.netloc])
    except ValueError:
        return False
    
# Ensure environment variables are set for Redis connection details
# REDIS_HOST = os.environ.get('REDIS_HOST',"redis://master.webscanclus1.ct1d8b.aps1.cache.amazonaws.com")
# if not REDIS_HOST:
#    raise ValueError('Missing environment variable REDIS_HOST')
# REDIS_PORT = int(os.environ.get('REDIS_PORT', 6379))  # Default port
# REDIS_PASSWORD = os.environ.get('REDIS_PASSWORD')

# Celery configuration (assuming you have Celery installed)
from celery import Celery
celery_app = Celery('tasks', broker=f'./')

# Set Celery result backend
celery_app.conf.update(
    result_backend=f'./'
)

# Error handling for potential connection issues
try:
    from kombu import Connection
    conn = Connection(f'./', connect_timeout=10)
except Exception as e:
    print(f'Error connecting to Redis: {e}')
    exit(1)

@celery_app.task
def scan_async(url):
    """
    Performs vulnerability scanning on the provided URL asynchronously.

    Args:
        url (str): The URL to scan.

    Returns:
        dict: A dictionary containing scan results for SQL injection, XSS, CSRF, and open redirect.
    """

    sql_injection_result = check_sql_injection(url)
    xss_result = check_xss(url)
    csrf_result = check_csrf(url)
    open_redirect_result = check_open_redirect(url)

    results = {
        "ID": str(uuid.uuid4()),  # Replace with a unique ID generation mechanism
        "URL": url,
        "SQL Injection": sql_injection_result,
        "XSS": xss_result,
        "CSRF": csrf_result,
        "Open Redirect": open_redirect_result
    }

    return results

def create_app():
    """
    Creates and configures the Flask application instance.
    """

    app = Flask(__name__)

    # Error handling for template rendering
    @app.errorhandler(Exception)
    def handle_exception(error):
        return render_template('error.html', error=error), 500

    @app.route('/')
    def index():
        """
        Renders the index page for user input.
        """

        return render_template('index.html')

    @app.route('/scan', methods=['POST'])
    def scan():
        """
        Handles user input, validates the URL, and initiates asynchronous scan.
        """

        url = request.form['url']
        if not url.startswith('http://') and not url.startswith('https://'):
            url = 'http://' + url

        try:
            # Validate URL format (consider adding more robust validation)
            if not is_valid_url(url):
                return render_template('error.html', error='Invalid URL format'), 400

            task = scan_async.delay(url)
            return redirect(url_for('results', task_id=task.id))

        except Exception as e:
            return render_template('error.html', error=f'Error processing URL: {e}'), 400

    @app.route('/results/<task_id>')
    def results(task_id):
        """
        Retrieves scan results from Celery and renders the results page.
        """

        from celery.result import AsyncResult
        result = AsyncResult(task_id)

        if not result.ready():
            return render_template('results_pending.html', task_id=task_id)

        return render_template('results.html', results=result.get())

    return app

if __name__ == '__main__':
    app = create_app()
    app.run(debug=True)